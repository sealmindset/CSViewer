{"ast":null,"code":"// utils.js\n// Function to flatten JSON and CSV data\nexport function flattenData(data, propertiesKey = \"PROPERTIES\") {\n  const flattenedData = [];\n  const headers = [];\n  function flattenObject(obj, prefix = \"\") {\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const value = obj[key];\n        if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n          flattenObject(value, prefix + key + \".\");\n        } else if (Array.isArray(value)) {\n          value.forEach((item, index) => {\n            if (typeof item === \"object\" && item !== null) {\n              flattenObject(item, `${prefix}${key}[${index}].`);\n            } else {\n              const newKey = `${prefix}${key}[${index}]`;\n              if (!headers.includes(newKey)) {\n                headers.push(newKey);\n              }\n              flattenedData.push({\n                [newKey]: item\n              });\n            }\n          });\n        } else {\n          const newKey = prefix + key;\n          if (!headers.includes(newKey)) {\n            headers.push(newKey);\n          }\n          flattenedData.push({\n            [newKey]: value\n          });\n        }\n      }\n    }\n  }\n  if (Array.isArray(data)) {\n    data.forEach(item => {\n      if (item.hasOwnProperty(propertiesKey) && typeof item[propertiesKey] === \"object\") {\n        const propertiesData = item[propertiesKey];\n        delete item[propertiesKey];\n        flattenObject(item);\n        for (const key in propertiesData) {\n          if (propertiesData.hasOwnProperty(key)) {\n            const value = propertiesData[key];\n            const newKey = `${propertiesKey}_${key}`;\n            if (!headers.includes(newKey)) {\n              headers.push(newKey);\n            }\n            flattenedData.push({\n              [newKey]: value\n            });\n          }\n        }\n      } else {\n        flattenObject(item);\n      }\n    });\n  } else if (typeof data === \"object\") {\n    // Single JSON object\n    if (data.hasOwnProperty(propertiesKey) && typeof data[propertiesKey] === \"object\") {\n      const propertiesData = data[propertiesKey];\n      delete data[propertiesKey];\n      flattenObject(data);\n      for (const key in propertiesData) {\n        if (propertiesData.hasOwnProperty(key)) {\n          const value = propertiesData[key];\n          const newKey = `${propertiesKey}_${key}`;\n          if (!headers.includes(newKey)) {\n            headers.push(newKey);\n          }\n          flattenedData.push({\n            [newKey]: value\n          });\n        }\n      }\n    } else {\n      flattenObject(data);\n    }\n  }\n  return {\n    headers,\n    data: flattenedData\n  };\n}\nexport function flattenJSON(jsonData, propertiesKey = \"PROPERTIES\") {\n  const flattenedData = [];\n  function flattenObject(obj, prefix = \"\") {\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const value = obj[key];\n        if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n          flattenObject(value, prefix + key + \"_\");\n        } else if (Array.isArray(value)) {\n          value.forEach((item, index) => {\n            if (typeof item === \"object\" && item !== null) {\n              flattenObject(item, `${prefix}${key}[${index}].`);\n            } else {\n              const newKey = `${prefix}${key}[${index}]`;\n              flattenedData.push({\n                [newKey]: item\n              });\n            }\n          });\n        } else {\n          const newKey = prefix + key;\n          flattenedData.push({\n            [newKey]: value\n          });\n        }\n      }\n    }\n  }\n  if (Array.isArray(jsonData)) {\n    jsonData.forEach(item => {\n      if (item.hasOwnProperty(propertiesKey) && typeof item[propertiesKey] === \"object\") {\n        const propertiesData = item[propertiesKey];\n        delete item[propertiesKey];\n        flattenObject(item);\n        for (const key in propertiesData) {\n          if (propertiesData.hasOwnProperty(key)) {\n            const value = propertiesData[key];\n            flattenedData.push({\n              [propertiesKey + \"_\" + key]: value\n            });\n          }\n        }\n      } else {\n        flattenObject(item);\n      }\n    });\n  } else if (typeof jsonData === \"object\") {\n    // Single JSON object\n    if (jsonData.hasOwnProperty(propertiesKey) && typeof jsonData[propertiesKey] === \"object\") {\n      const propertiesData = jsonData[propertiesKey];\n      delete jsonData[propertiesKey];\n      flattenObject(jsonData);\n      for (const key in propertiesData) {\n        if (propertiesData.hasOwnProperty(key)) {\n          const value = propertiesData[key];\n          flattenedData.push({\n            [propertiesKey + \"_\" + key]: value\n          });\n        }\n      }\n    } else {\n      flattenObject(jsonData);\n    }\n  }\n  return flattenedData;\n}\nexport function flattenJSONColumns(data, renamedHeaders) {\n  const flattenedRows = [];\n  function flattenObject(obj, prefix = \"\") {\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const value = obj[key];\n        if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n          flattenObject(value, prefix + key + \".\");\n        } else if (Array.isArray(value)) {\n          value.forEach((item, index) => {\n            if (typeof item === \"object\" && item !== null) {\n              flattenObject(item, `${prefix}${key}[${index}].`);\n            } else {\n              const newHeader = renamedHeaders[key] || key;\n              flattenedRows.push({\n                [newHeader]: item\n              });\n            }\n          });\n        } else {\n          const newHeader = renamedHeaders[key] || key;\n          flattenedRows.push({\n            [newHeader]: value\n          });\n        }\n      }\n    }\n  }\n  data.forEach(row => {\n    const newRow = {}; // Create a new object for each row to avoid modifying the original data\n    for (const header in row) {\n      if (row.hasOwnProperty(header)) {\n        const value = row[header];\n        if (typeof value === \"object\" && value !== null) {\n          flattenObject(value, header + \".\");\n        } else {\n          const newHeader = renamedHeaders[header] || header;\n          newRow[newHeader] = value;\n        }\n      }\n    }\n    flattenedRows.push(newRow); // Add the flattened row to the end of the array\n  });\n\n  return flattenedRows;\n}\nexport function flattenProperties(data) {\n  const flattenedData = {};\n  function flattenObject(obj, parentKey = '') {\n    for (const key in obj) {\n      const value = obj[key];\n      const newKey = parentKey ? `${parentKey}_${key}` : key;\n      if (typeof value === 'object' && value !== null) {\n        flattenObject(value, newKey);\n      } else {\n        flattenedData[newKey] = value;\n      }\n    }\n  }\n  try {\n    const parsedData = JSON.parse(data);\n    flattenObject(parsedData);\n  } catch (error) {\n    const [key, value] = data.split(':').map(item => item.trim());\n    flattenedData[key] = value;\n  }\n  return flattenedData;\n}","map":{"version":3,"names":["flattenData","data","propertiesKey","flattenedData","headers","flattenObject","obj","prefix","key","hasOwnProperty","value","Array","isArray","forEach","item","index","newKey","includes","push","propertiesData","flattenJSON","jsonData","flattenJSONColumns","renamedHeaders","flattenedRows","newHeader","row","newRow","header","flattenProperties","parentKey","parsedData","JSON","parse","error","split","map","trim"],"sources":["/Users/robvance/Documents/GitHub/CSViewer/src/utils.js"],"sourcesContent":["// utils.js\n// Function to flatten JSON and CSV data\nexport function flattenData(data, propertiesKey = \"PROPERTIES\") {\n  const flattenedData = [];\n  const headers = [];\n  \n  function flattenObject(obj, prefix = \"\") {\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const value = obj[key];\n        if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n          flattenObject(value, prefix + key + \".\");\n        } else if (Array.isArray(value)) {\n          value.forEach((item, index) => {\n            if (typeof item === \"object\" && item !== null) {\n              flattenObject(item, `${prefix}${key}[${index}].`);\n            } else {\n              const newKey = `${prefix}${key}[${index}]`;\n              if (!headers.includes(newKey)) {\n                headers.push(newKey);\n              }\n              flattenedData.push({ [newKey]: item });\n            }\n          });\n        } else {\n          const newKey = prefix + key;\n          if (!headers.includes(newKey)) {\n            headers.push(newKey);\n          }\n          flattenedData.push({ [newKey]: value });\n        }\n      }\n    }\n  }\n\n  if (Array.isArray(data)) {\n    data.forEach((item) => {\n      if (item.hasOwnProperty(propertiesKey) && typeof item[propertiesKey] === \"object\") {\n        const propertiesData = item[propertiesKey];\n        delete item[propertiesKey];\n        flattenObject(item);\n        for (const key in propertiesData) {\n          if (propertiesData.hasOwnProperty(key)) {\n            const value = propertiesData[key];\n            const newKey = `${propertiesKey}_${key}`;\n            if (!headers.includes(newKey)) {\n              headers.push(newKey);\n            }\n            flattenedData.push({ [newKey]: value });\n          }\n        }\n      } else {\n        flattenObject(item);\n      }\n    });\n  } else if (typeof data === \"object\") {\n    // Single JSON object\n    if (data.hasOwnProperty(propertiesKey) && typeof data[propertiesKey] === \"object\") {\n      const propertiesData = data[propertiesKey];\n      delete data[propertiesKey];\n      flattenObject(data);\n      for (const key in propertiesData) {\n        if (propertiesData.hasOwnProperty(key)) {\n          const value = propertiesData[key];\n          const newKey = `${propertiesKey}_${key}`;\n          if (!headers.includes(newKey)) {\n            headers.push(newKey);\n          }\n          flattenedData.push({ [newKey]: value });\n        }\n      }\n    } else {\n      flattenObject(data);\n    }\n  }\n\n  return { headers, data: flattenedData };\n}\n\nexport function flattenJSON(jsonData, propertiesKey = \"PROPERTIES\") {\n  const flattenedData = [];\n\n  function flattenObject(obj, prefix = \"\") {\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const value = obj[key];\n        if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n          flattenObject(value, prefix + key + \"_\");\n        } else if (Array.isArray(value)) {\n          value.forEach((item, index) => {\n            if (typeof item === \"object\" && item !== null) {\n              flattenObject(item, `${prefix}${key}[${index}].`);\n            } else {\n              const newKey = `${prefix}${key}[${index}]`;\n              flattenedData.push({ [newKey]: item });\n            }\n          });\n        } else {\n          const newKey = prefix + key;\n          flattenedData.push({ [newKey]: value });\n        }\n      }\n    }\n  }\n\n  if (Array.isArray(jsonData)) {\n    jsonData.forEach((item) => {\n      if (item.hasOwnProperty(propertiesKey) && typeof item[propertiesKey] === \"object\") {\n        const propertiesData = item[propertiesKey];\n        delete item[propertiesKey];\n        flattenObject(item);\n        for (const key in propertiesData) {\n          if (propertiesData.hasOwnProperty(key)) {\n            const value = propertiesData[key];\n            flattenedData.push({ [propertiesKey + \"_\" + key]: value });\n          }\n        }\n      } else {\n        flattenObject(item);\n      }\n    });\n  } else if (typeof jsonData === \"object\") {\n    // Single JSON object\n    if (jsonData.hasOwnProperty(propertiesKey) && typeof jsonData[propertiesKey] === \"object\") {\n      const propertiesData = jsonData[propertiesKey];\n      delete jsonData[propertiesKey];\n      flattenObject(jsonData);\n      for (const key in propertiesData) {\n        if (propertiesData.hasOwnProperty(key)) {\n          const value = propertiesData[key];\n          flattenedData.push({ [propertiesKey + \"_\" + key]: value });\n        }\n      }\n    } else {\n      flattenObject(jsonData);\n    }\n  }\n\n  return flattenedData;\n}\n\nexport function flattenJSONColumns(data, renamedHeaders) {\n  const flattenedRows = [];\n\n  function flattenObject(obj, prefix = \"\") {\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const value = obj[key];\n        if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n          flattenObject(value, prefix + key + \".\");\n        } else if (Array.isArray(value)) {\n          value.forEach((item, index) => {\n            if (typeof item === \"object\" && item !== null) {\n              flattenObject(item, `${prefix}${key}[${index}].`);\n            } else {\n              const newHeader = renamedHeaders[key] || key;\n              flattenedRows.push({ [newHeader]: item });\n            }\n          });\n        } else {\n          const newHeader = renamedHeaders[key] || key;\n          flattenedRows.push({ [newHeader]: value });\n        }\n      }\n    }\n  }\n\n  data.forEach((row) => {\n    const newRow = {}; // Create a new object for each row to avoid modifying the original data\n    for (const header in row) {\n      if (row.hasOwnProperty(header)) {\n        const value = row[header];\n        if (typeof value === \"object\" && value !== null) {\n          flattenObject(value, header + \".\");\n        } else {\n          const newHeader = renamedHeaders[header] || header;\n          newRow[newHeader] = value;\n        }\n      }\n    }\n    flattenedRows.push(newRow); // Add the flattened row to the end of the array\n  });\n\n  return flattenedRows;\n}\n\n\nexport function flattenProperties(data) {\n  const flattenedData = {};\n\n  function flattenObject(obj, parentKey = '') {\n    for (const key in obj) {\n      const value = obj[key];\n      const newKey = parentKey ? `${parentKey}_${key}` : key;\n\n      if (typeof value === 'object' && value !== null) {\n        flattenObject(value, newKey);\n      } else {\n        flattenedData[newKey] = value;\n      }\n    }\n  }\n\n  try {\n    const parsedData = JSON.parse(data);\n    flattenObject(parsedData);\n  } catch (error) {\n    const [key, value] = data.split(':').map((item) => item.trim());\n    flattenedData[key] = value;\n  }\n\n  return flattenedData;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}