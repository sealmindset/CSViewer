{"ast":null,"code":"import Papa from 'papaparse';\nexport const flattenProperties = data => {\n  console.log(\"Received data:\", data);\n  const result = {};\n  const recurse = (cur, prop) => {\n    if (Object(cur) !== cur) {\n      result[prop] = cur;\n    } else if (Array.isArray(cur)) {\n      for (let i = 0, l = cur.length; i < l; i++) {\n        recurse(cur[i], `${prop}[${i}]`);\n        if (l == 0) {\n          result[prop] = [];\n        }\n      }\n    } else {\n      let isEmpty = true;\n      for (const p in cur) {\n        isEmpty = false;\n        recurse(cur[p], prop ? `${prop}.${p}` : p);\n      }\n      if (isEmpty && prop) {\n        result[prop] = {};\n      }\n    }\n  };\n  recurse(data, \"\");\n  console.log(\"Flattened result:\", result);\n  return result;\n};\nexport const mergeRow = (flattenedProperties, originalRow) => {\n  const newRow = {\n    ...originalRow\n  };\n\n  // Check if the PROPERTIES column exists in the originalRow and is a valid JSON string\n  if (originalRow.hasOwnProperty('PROPERTIES')) {\n    try {\n      const properties = JSON.parse(originalRow.PROPERTIES);\n      if (typeof properties === 'object' && properties !== null) {\n        // Merge properties object with newRow, handling nested objects\n        const mergeObjects = (obj, parentKey = '') => {\n          for (const key in obj) {\n            const value = obj[key];\n            const newKey = parentKey ? `${parentKey}_${key}` : key;\n            if (typeof value === 'object' && value !== null) {\n              mergeObjects(value, newKey);\n            } else {\n              newRow[newKey] = value;\n            }\n          }\n        };\n        mergeObjects(properties);\n      }\n    } catch (error) {\n      console.warn('Error parsing PROPERTIES column:', error);\n    }\n  }\n\n  // Merge flattenedProperties into newRow\n  for (const key in flattenedProperties) {\n    newRow[key] = flattenedProperties[key];\n  }\n  return newRow;\n};","map":{"version":3,"names":["Papa","flattenProperties","data","console","log","result","recurse","cur","prop","Object","Array","isArray","i","l","length","isEmpty","p","mergeRow","flattenedProperties","originalRow","newRow","hasOwnProperty","properties","JSON","parse","PROPERTIES","mergeObjects","obj","parentKey","key","value","newKey","error","warn"],"sources":["/Users/robvance/Documents/GitHub/CSViewer/src/JSONFlattener.js"],"sourcesContent":["import Papa from 'papaparse';\n\nexport const flattenProperties = (data) => {\n  console.log(\"Received data:\", data);\n\n  const result = {};\n  const recurse = (cur, prop) => {\n    if (Object(cur) !== cur) {\n      result[prop] = cur;\n    } else if (Array.isArray(cur)) {\n      for (let i = 0, l = cur.length; i < l; i++) {\n        recurse(cur[i], `${prop}[${i}]`);\n        if (l == 0) {\n          result[prop] = [];\n        }\n      }\n    } else {\n      let isEmpty = true;\n      for (const p in cur) {\n        isEmpty = false;\n        recurse(cur[p], prop ? `${prop}.${p}` : p);\n      }\n      if (isEmpty && prop) {\n        result[prop] = {};\n      }\n    }\n  };\n  recurse(data, \"\");\n\n  console.log(\"Flattened result:\", result);\n  return result;\n};\n\n\nexport const mergeRow = (flattenedProperties, originalRow) => {\n  const newRow = { ...originalRow };\n\n  // Check if the PROPERTIES column exists in the originalRow and is a valid JSON string\n  if (originalRow.hasOwnProperty('PROPERTIES')) {\n    try {\n      const properties = JSON.parse(originalRow.PROPERTIES);\n      if (typeof properties === 'object' && properties !== null) {\n        // Merge properties object with newRow, handling nested objects\n        const mergeObjects = (obj, parentKey = '') => {\n          for (const key in obj) {\n            const value = obj[key];\n            const newKey = parentKey ? `${parentKey}_${key}` : key;\n\n            if (typeof value === 'object' && value !== null) {\n              mergeObjects(value, newKey);\n            } else {\n              newRow[newKey] = value;\n            }\n          }\n        };\n        mergeObjects(properties);\n      }\n    } catch (error) {\n      console.warn('Error parsing PROPERTIES column:', error);\n    }\n  }\n\n  // Merge flattenedProperties into newRow\n  for (const key in flattenedProperties) {\n    newRow[key] = flattenedProperties[key];\n  }\n\n  return newRow;\n};\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,WAAW;AAE5B,OAAO,MAAMC,iBAAiB,GAAIC,IAAI,IAAK;EACzCC,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEF,IAAI,CAAC;EAEnC,MAAMG,MAAM,GAAG,CAAC,CAAC;EACjB,MAAMC,OAAO,GAAGA,CAACC,GAAG,EAAEC,IAAI,KAAK;IAC7B,IAAIC,MAAM,CAACF,GAAG,CAAC,KAAKA,GAAG,EAAE;MACvBF,MAAM,CAACG,IAAI,CAAC,GAAGD,GAAG;IACpB,CAAC,MAAM,IAAIG,KAAK,CAACC,OAAO,CAACJ,GAAG,CAAC,EAAE;MAC7B,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGN,GAAG,CAACO,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;QAC1CN,OAAO,CAACC,GAAG,CAACK,CAAC,CAAC,EAAG,GAAEJ,IAAK,IAAGI,CAAE,GAAE,CAAC;QAChC,IAAIC,CAAC,IAAI,CAAC,EAAE;UACVR,MAAM,CAACG,IAAI,CAAC,GAAG,EAAE;QACnB;MACF;IACF,CAAC,MAAM;MACL,IAAIO,OAAO,GAAG,IAAI;MAClB,KAAK,MAAMC,CAAC,IAAIT,GAAG,EAAE;QACnBQ,OAAO,GAAG,KAAK;QACfT,OAAO,CAACC,GAAG,CAACS,CAAC,CAAC,EAAER,IAAI,GAAI,GAAEA,IAAK,IAAGQ,CAAE,EAAC,GAAGA,CAAC,CAAC;MAC5C;MACA,IAAID,OAAO,IAAIP,IAAI,EAAE;QACnBH,MAAM,CAACG,IAAI,CAAC,GAAG,CAAC,CAAC;MACnB;IACF;EACF,CAAC;EACDF,OAAO,CAACJ,IAAI,EAAE,EAAE,CAAC;EAEjBC,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAEC,MAAM,CAAC;EACxC,OAAOA,MAAM;AACf,CAAC;AAGD,OAAO,MAAMY,QAAQ,GAAGA,CAACC,mBAAmB,EAAEC,WAAW,KAAK;EAC5D,MAAMC,MAAM,GAAG;IAAE,GAAGD;EAAY,CAAC;;EAEjC;EACA,IAAIA,WAAW,CAACE,cAAc,CAAC,YAAY,CAAC,EAAE;IAC5C,IAAI;MACF,MAAMC,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACL,WAAW,CAACM,UAAU,CAAC;MACrD,IAAI,OAAOH,UAAU,KAAK,QAAQ,IAAIA,UAAU,KAAK,IAAI,EAAE;QACzD;QACA,MAAMI,YAAY,GAAGA,CAACC,GAAG,EAAEC,SAAS,GAAG,EAAE,KAAK;UAC5C,KAAK,MAAMC,GAAG,IAAIF,GAAG,EAAE;YACrB,MAAMG,KAAK,GAAGH,GAAG,CAACE,GAAG,CAAC;YACtB,MAAME,MAAM,GAAGH,SAAS,GAAI,GAAEA,SAAU,IAAGC,GAAI,EAAC,GAAGA,GAAG;YAEtD,IAAI,OAAOC,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,EAAE;cAC/CJ,YAAY,CAACI,KAAK,EAAEC,MAAM,CAAC;YAC7B,CAAC,MAAM;cACLX,MAAM,CAACW,MAAM,CAAC,GAAGD,KAAK;YACxB;UACF;QACF,CAAC;QACDJ,YAAY,CAACJ,UAAU,CAAC;MAC1B;IACF,CAAC,CAAC,OAAOU,KAAK,EAAE;MACd7B,OAAO,CAAC8B,IAAI,CAAC,kCAAkC,EAAED,KAAK,CAAC;IACzD;EACF;;EAEA;EACA,KAAK,MAAMH,GAAG,IAAIX,mBAAmB,EAAE;IACrCE,MAAM,CAACS,GAAG,CAAC,GAAGX,mBAAmB,CAACW,GAAG,CAAC;EACxC;EAEA,OAAOT,MAAM;AACf,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}